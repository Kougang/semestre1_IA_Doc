<sami><head><Title></Title><style type='text/css'><!--.en { Name:English (auto-generated) ;lang:en; SAMIType:CC;}--></style><SYNC Start=829><P class='en'>hey everyone welcome to video 1 in a<SYNC Start=4048><P class='en'>part three series of punctures pra√ßa dos<SYNC Start=7410><P class='en'>and monads in Haskell this video will be<SYNC Start=10050><P class='en'>honourable functors so let&#39;s begin I&#39;m<SYNC Start=13980><P class='en'>just gonna start off by writing the<SYNC Start=15240><P class='en'>definition here and then we&#39;re gonna<SYNC Start=17070><P class='en'>work our three way through it and don&#39;t<SYNC Start=19289><P class='en'>make sense by the end so firstly a<SYNC Start=21500><P class='en'>functor is a type class now what is the<SYNC Start=27660><P class='en'>type class a type class you can think of<SYNC Start=32398><P class='en'>it as an interface it&#39;s not really an<SYNC Start=35309><P class='en'>interface but you can think of it as an<SYNC Start=37230><P class='en'>interface so what that means is that the<SYNC Start=40020><P class='en'>function is a type class and it defines<SYNC Start=41969><P class='en'>or it gives us the signature for a<SYNC Start=44460><P class='en'>method and we have to implement that<SYNC Start=47129><P class='en'>method on our own so this is what it<SYNC Start=49559><P class='en'>looks like in Haskell so we&#39;re gonna do<SYNC Start=52800><P class='en'>class functor F where F map F map is the<SYNC Start=58739><P class='en'>function that it gives us the signature<SYNC Start=60480><P class='en'>for to be F a FB so this is exactly what<SYNC Start=68369><P class='en'>it looks like and I&#39;m gonna explain how<SYNC Start=70380><P class='en'>this works so in Haskell we have<SYNC Start=75450><P class='en'>something called a rapid value and we<SYNC Start=77549><P class='en'>have something called an unwrapped value<SYNC Start=79049><P class='en'>what is it wrap to value<SYNC Start=80970><P class='en'>well sorry what is it unwrapped I unwrap<SYNC Start=83100><P class='en'>values basically just a value on its own<SYNC Start=84780><P class='en'>for example let&#39;s say I had +3 applied<SYNC Start=87900><P class='en'>to something like 9 the 9 here is an<SYNC Start=90869><P class='en'>unwrapped value because it&#39;s not<SYNC Start=92040><P class='en'>surrounded by anything a wrapped value<SYNC Start=94860><P class='en'>is something that is surrounded by<SYNC Start=96360><P class='en'>something the obvious case here is an<SYNC Start=99810><P class='en'>example that might come to your head is<SYNC Start=101130><P class='en'>in maybe so in asked what we have this<SYNC Start=105270><P class='en'>maybe object which is basically just a<SYNC Start=108240><P class='en'>or nothing right so in this case what we<SYNC Start=114450><P class='en'>have what&#39;s if I do just eight we<SYNC Start=116700><P class='en'>consider or we say that 8 is a wrapped<SYNC Start=119790><P class='en'>and adjust and I think this photo here<SYNC Start=122820><P class='en'>illustrates the best that we have an a<SYNC Start=125729><P class='en'>inside and then it wrapped around it&#39;s<SYNC Start=128160><P class='en'>wrapped around by something if I wanted<SYNC Start=131520><P class='en'>to apply a function to this just<SYNC Start=133170><P class='en'>eight how would I do it I can&#39;t do this<SYNC Start=137340><P class='en'>can I<SYNC Start=138230><P class='en'>it won&#39;t work I can do +3 9 to unwrapped<SYNC Start=143010><P class='en'>value but to a rapid value it doesn&#39;t<SYNC Start=145110><P class='en'>matter what to a rapt value it does not<SYNC Start=147450><P class='en'>work and that&#39;s where the functor comes<SYNC Start=149819><P class='en'>into play a functor essentially what it<SYNC Start=152610><P class='en'>does it takes in a function so here&#39;s<SYNC Start=155040><P class='en'>how we will call it will call f map will<SYNC Start=157500><P class='en'>call some sort of functions LS c plus 3<SYNC Start=159420><P class='en'>and we&#39;d pass in our f of a so maybe<SYNC Start=163590><P class='en'>this is like a wrapped value and then<SYNC Start=166019><P class='en'>what it should give us in the end<SYNC Start=167569><P class='en'>it&#39;s just seven so it gives us the<SYNC Start=169860><P class='en'>wrapped are you back where the function<SYNC Start=171750><P class='en'>here has been applied to this internal<SYNC Start=173880><P class='en'>variable so let&#39;s exactly see how we&#39;re<SYNC Start=176700><P class='en'>gonna make that happen in maybe so I&#39;m<SYNC Start=179580><P class='en'>gonna define maybe two here I tend to<SYNC Start=183060><P class='en'>cut two maybe<SYNC Start=183720><P class='en'>and as you can see so I&#39;m just to eight<SYNC Start=189420><P class='en'>and obviously have to derive show in<SYNC Start=193200><P class='en'>order for it to show so I did just to<SYNC Start=195390><P class='en'>eight as you can see it&#39;s here I&#39;m gonna<SYNC Start=197579><P class='en'>apply this functor to maybe two how I&#39;m<SYNC Start=203310><P class='en'>gonna do that is I&#39;m gonna write<SYNC Start=204450><P class='en'>instance functor maybe to where so<SYNC Start=211410><P class='en'>remember we have to code this F map<SYNC Start=215010><P class='en'>function which is what has God finds f<SYNC Start=217470><P class='en'>MA now we have to call the two cases so<SYNC Start=221030><P class='en'>function just to a is equal to and F<SYNC Start=227090><P class='en'>function<SYNC Start=228709><P class='en'>nothing is equal if wondering why is<SYNC Start=231510><P class='en'>this function here well this is a<SYNC Start=233220><P class='en'>function right over here a to be this<SYNC Start=235470><P class='en'>just a is our f of a I&#39;m not gonna<SYNC Start=238799><P class='en'>return an F of B well the easy case here<SYNC Start=241829><P class='en'>is that if I pass in nothing or if I&#39;m<SYNC Start=244890><P class='en'>getting in nothing then regardless of<SYNC Start=246660><P class='en'>the function I apply I should get back<SYNC Start=248459><P class='en'>nothing that makes sense if I have a<SYNC Start=252269><P class='en'>chest and I&#39;m trying a function then I<SYNC Start=255269><P class='en'>want to apply the function to the<SYNC Start=256799><P class='en'>internal value which is a and then I<SYNC Start=259560><P class='en'>want to wrap it around in a just<SYNC Start=263290><P class='en'>so this is how it is this is how easy it<SYNC Start=265750><P class='en'>works for which to do it again now let<SYNC Start=268810><P class='en'>me do something like Earth Map the<SYNC Start=272770><P class='en'>function here is plus three and gonna do<SYNC Start=275020><P class='en'>just two eight now you&#39;re gonna see it<SYNC Start=278740><P class='en'>gives me just 211 and something about<SYNC Start=281200><P class='en'>Haskell is that it already defines it<SYNC Start=282940><P class='en'>for a bunch of stuff a bunch of data<SYNC Start=285310><P class='en'>types it already defines the functor<SYNC Start=286870><P class='en'>method for example the regular just it&#39;s<SYNC Start=291310><P class='en'>already defined as if I was to do just<SYNC Start=293080><P class='en'>eight it&#39;s already defined right over<SYNC Start=295270><P class='en'>there it&#39;s also defined in list it&#39;s<SYNC Start=297550><P class='en'>also defined in either so in a list that<SYNC Start=300040><P class='en'>actually becomes very easy because in a<SYNC Start=303010><P class='en'>list if I was to do Earth Map we do plus<SYNC Start=305380><P class='en'>three one two three<SYNC Start=307060><P class='en'>well we have four five six the reason<SYNC Start=309460><P class='en'>here is that F map in the list is<SYNC Start=311500><P class='en'>actually equal to just map right because<SYNC Start=315310><P class='en'>if I was to do map plus three one two<SYNC Start=317740><P class='en'>three<SYNC Start=318160><P class='en'>I would get back the same exact thing so<SYNC Start=321040><P class='en'>that&#39;s what a functor is a functor<SYNC Start=323050><P class='en'>basically what it does is it applies a<SYNC Start=325270><P class='en'>function to a wrapped value and gives us<SYNC Start=328540><P class='en'>a raptor value back so functors when<SYNC Start=332740><P class='en'>you&#39;re gonna be using them they&#39;re gonna<SYNC Start=334360><P class='en'>be there it&#39;s gonna be very tedious to<SYNC Start=337150><P class='en'>keep earning f map f map every time so<SYNC Start=339610><P class='en'>high school offers an infix notation<SYNC Start=341410><P class='en'>infix basically means in between and<SYNC Start=344010><P class='en'>essentially what you do is we have a<SYNC Start=346690><P class='en'>function then it&#39;s the angle brace the<SYNC Start=350380><P class='en'>dollar sign and go brace again and then<SYNC Start=353670><P class='en'>the item or the wrapped value and then<SYNC Start=358150><P class='en'>we&#39;re gonna get the same thing back so<SYNC Start=359290><P class='en'>this this thing here it&#39;s identical to<SYNC Start=362050><P class='en'>same f map plus three just do for it I<SYNC Start=365500><P class='en'>tend to go to saying that it&#39;s just in<SYNC Start=367360><P class='en'>Haskell it&#39;s easier if you have an infix<SYNC Start=370300><P class='en'>notation just like this so we know that<SYNC Start=373690><P class='en'>Haskell offers the functors for maybe<SYNC Start=377110><P class='en'>either list and a bunch of other stuff<SYNC Start=379540><P class='en'>but most of the time you want to apply<SYNC Start=381400><P class='en'>functors to your own programs or your<SYNC Start=383950><P class='en'>own data structures so the most common<SYNC Start=386650><P class='en'>example is a tree and the tree how we&#39;re<SYNC Start=390850><P class='en'>going to define it is the following way<SYNC Start=392380><P class='en'>so just gonna have data tree<SYNC Start=394630><P class='en'>is equal to so it&#39;s gonna have a chip<SYNC Start=397320><P class='en'>and it&#39;s gonna be a branch so in branch<SYNC Start=401650><P class='en'>we&#39;ll have 3a and tree so I&#39;ll show you<SYNC Start=405310><P class='en'>an example of what this might look like<SYNC Start=406950><P class='en'>something like this so here&#39;s a tree the<SYNC Start=413110><P class='en'>4 5 &amp; 6 are tips and these individual<SYNC Start=415510><P class='en'>things right over here are the branches<SYNC Start=416800><P class='en'>so this would be something with this<SYNC Start=418930><P class='en'>branch tip 4 and then branch tip 5 and<SYNC Start=422950><P class='en'>then tip 6 this is what it will look<SYNC Start=424390><P class='en'>like when you apply F map to it we apply<SYNC Start=427630><P class='en'>it at the tips and this is our resultant<SYNC Start=430990><P class='en'>tree so this is an example that it&#39;s not<SYNC Start=434380><P class='en'>implemented by Haskell and we&#39;re gonna<SYNC Start=435790><P class='en'>implement it right now so again we do<SYNC Start=438820><P class='en'>the same way so we do instance function<SYNC Start=441910><P class='en'>tree where again we have two cases so we<SYNC Start=445810><P class='en'>have F map function we&#39;re gonna have a<SYNC Start=449230><P class='en'>tip a I&#39;m gonna have map function I&#39;m<SYNC Start=453100><P class='en'>gonna have branch left and then right<SYNC Start=456300><P class='en'>what the tip a is easy because all we<SYNC Start=459040><P class='en'>need to do here is apply the function so<SYNC Start=462820><P class='en'>functionally and surrounded by a tip the<SYNC Start=467800><P class='en'>branch so the branch is different<SYNC Start=469600><P class='en'>because again we still need to<SYNC Start=472750><P class='en'>surrounded by a branch as per the type<SYNC Start=477580><P class='en'>construct but what will be the two<SYNC Start=481090><P class='en'>things are over here well we know that<SYNC Start=483070><P class='en'>in a branch if it&#39;s a left and if it&#39;s a<SYNC Start=485260><P class='en'>right we can&#39;t apply the function we<SYNC Start=487630><P class='en'>can&#39;t apply F map just yet because it<SYNC Start=490450><P class='en'>needs to go all the way down to a tip so<SYNC Start=492670><P class='en'>what we&#39;re gonna do is we&#39;re gonna<SYNC Start=493540><P class='en'>recurse and now we&#39;re going to recurse<SYNC Start=495670><P class='en'>is f map F left and F map F rights and<SYNC Start=502300><P class='en'>we could have again wrote F map F right<SYNC Start=504970><P class='en'>as F infix operator right just to save<SYNC Start=509650><P class='en'>space but I think it&#39;s much clearer this<SYNC Start=512169><P class='en'>way so this is a pattern you&#39;re gonna<SYNC Start=513669><P class='en'>see when you&#39;re at your most basic case<SYNC Start=516039><P class='en'>you just apply the function otherwise<SYNC Start=517990><P class='en'>you can ever curse so that&#39;s this let&#39;s<SYNC Start=522099><P class='en'>just take a look at it with a bunch of<SYNC Start=524500><P class='en'>errors<SYNC Start=525220><P class='en'>F this should be function function<SYNC Start=531910><P class='en'>rights and there should work so let me<SYNC Start=537220><P class='en'>just put deriving show here so I can<SYNC Start=538900><P class='en'>show you an example and she I&#39;ll just<SYNC Start=541><P class='en'>just copy and paste this so let&#39;s say X<SYNC Start=545500><P class='en'>is equal to the following so X is equal<SYNC Start=547960><P class='en'>to following that&#39;s clear and then what<SYNC Start=550780><P class='en'>I want to do is I want to apply a flap<SYNC Start=554320><P class='en'>let&#39;s do plus 3/2 X and as you can see<SYNC Start=557800><P class='en'>it works properly originally X was this<SYNC Start=560320><P class='en'>and it has applied 3 to each and every<SYNC Start=563620><P class='en'>one of them so know this video was kind<SYNC Start=565900><P class='en'>of long but it was basically just to lay<SYNC Start=567490><P class='en'>out what a functor is and how we&#39;re<SYNC Start=570550><P class='en'>gonna use it so we showed an example of<SYNC Start=572470><P class='en'>where it&#39;s already used and then created<SYNC Start=574480><P class='en'>our own example to show how we can use<SYNC Start=576400><P class='en'>it in our own programs I hope you<SYNC Start=578440><P class='en'>enjoyed this video and if you have any<SYNC Start=579850><P class='en'>questions please leave them in the<SYNC Start=581200><P class='en'>comments otherwise I&#39;ll see you in the<SYNC Start=583660><P class='en'>next video thank you</body></sami>